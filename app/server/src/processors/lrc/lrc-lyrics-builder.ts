import fs from 'node:fs';
import path from 'node:path';

import type { AssLine, LyricBuilderAssOptions } from 'jaraoke-shared/types';

interface LyricBuilderOptions {
  lrcFile: string;
}

interface LRCLine {
  startTime: number;
  str: string;
}

export const lrcLyricBuilder = (opts: LyricBuilderOptions) => {
  const fileContents = fs.readFileSync(opts.lrcFile).toString();
  const lyricLines: LRCLine[] = fileContents
    .split('\n')
    .map((line: string) => {
      const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2})\](.*)/);
      const startTime = match
        ? parseInt(match[1], 10) * 6000 +
          parseInt(match[2], 10) * 100 +
          parseInt(match[3], 10)
        : -1;

      if (startTime === -1) {
        return null;
      }

      const str = match ? match[4].trim() : line.trim();
      return { startTime, str };
    })
    .filter((x) => x != null);

  const convertTiming = (value: number) => {
    const minutes = Math.floor(value / 6000);
    const seconds = Math.floor((value - minutes * 6000) / 100);
    const ms = Math.floor(value - (minutes * 6000 + seconds * 100));

    const pad = (num: number) => num.toString().padStart(2, '0');

    return `${pad(minutes)}:${pad(seconds)}.${pad(ms)}`;
  };

  const toAss = (options?: Pick<LyricBuilderAssOptions, 'font' | 'fontSize' | 'highlightColour' | 'screen'>) => {
    const {
      font = 'IMPACT',
      fontSize = 48,
      highlightColour = '&H00FF00&',
      screen,
    } = options || {};

    const { width = 1280, height = 720 } = screen || {};

    const initialStartPos = height / 3;
    const positions = Array(3)
      .fill((_: any) => undefined)
      .map((_, i) => initialStartPos + fontSize * i);
    const CENTER_X = width / 2;

    const ASS_TEMPLATE = `[Script Info]
; Script generated by Aegisub 3.4.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1280
PlayResY: 720

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${font},${fontSize},&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Countdown,Arial Black,80,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,5,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

    const assLines: string[] = [];
    const lines: AssLine[] = [];
    const HIGHLIGHT_TEMPLATE = `\\r\\1c${highlightColour}\\b1`;

    for (let i = 0; i < lyricLines.length; i++) {
      const line = lyricLines[i];
      const startingTiming = line.startTime;

      const start = i === 0 ? startingTiming - 200 : startingTiming;

      lines.push({
        start,
        end: startingTiming,
        lyric: line.str,
      });
    }

    for(let i = 0; i < lines.length; i++) {
      const chunk: AssLine[] = [
        lines[i - 1],
        lines[i],
        lines[i + 1]
      ];

      const startTiming = convertTiming(chunk[1].start);
      const endTiming = convertTiming(chunk[2]?.start || chunk[1].end);

      for(let j = 0; j < chunk.length; j++) {
        const line = chunk[j];
        const pos = positions[j];

        const lyric = line?.lyric || '';
        const prefixTemplate = j == 1 ? `{${HIGHLIGHT_TEMPLATE}\\pos(${CENTER_X},${pos})}` : `{\\pos(${CENTER_X},${pos})}`;
        const formattedLine = `Dialogue: 0,0:${startTiming},0:${endTiming},Default,,0,0,0,,${prefixTemplate}${lyric}`;
        assLines.push(formattedLine);
      }
    }

    return `${ASS_TEMPLATE}${assLines.join('\n')}`;
  };

  return {
    toAss,
  };
};
