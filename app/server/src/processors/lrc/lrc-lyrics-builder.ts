import fs from 'node:fs';
import path from 'node:path';

import type { AssLine, LyricBuilderAssOptions } from 'jaraoke-shared/types';

interface LyricBuilderOptions {
  lrcFile: string;
}

interface LRCLine {
  startTime: number;
  str: string;
}

export const lrcLyricBuilder = (opts: LyricBuilderOptions) => {
  const fileContents = fs.readFileSync(opts.lrcFile).toString();
  const lyricLines: LRCLine[] = fileContents
    .split('\n')
    .map((line) => {
      const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2})\](.*)/);
      const startTime = match
        ? parseInt(match[1], 10) * 6000 +
          parseInt(match[2], 10) * 100 +
          parseInt(match[3], 10)
        : -1;

      if (startTime === -1) {
        return null;
      }

      const str = match ? match[4].trim() : line.trim();
      return { startTime, str };
    })
    .filter((x) => x != null);

  const convertTiming = (value: number) => {
    const minutes = Math.floor(value / 6000);
    const seconds = Math.floor((value - minutes * 6000) / 100);
    const ms = Math.floor(value - (minutes * 6000 + seconds * 100));

    const pad = (num: number) => num.toString().padStart(2, '0');

    return `${pad(minutes)}:${pad(seconds)}.${pad(ms)}`;
  };

  const constructCountdown = (
    firstTiming: number,
    startingNumber: number = 3,
    paddingTiming: number = 100,
  ): AssLine[] => {
    return Array(startingNumber)
      .fill(() => undefined)
      .map((_, index) => {
        const number = startingNumber - index;
        const centiseconds = number * 100;

        return {
          start: firstTiming - centiseconds - 100 - paddingTiming,
          end: firstTiming - centiseconds - paddingTiming,
          lyric: `{\\fad(300,300)}${number}`,
          style: 'Countdown',
        };
      });
  };

  const toAss = (options?: LyricBuilderAssOptions) => {
    const {
      paddingTiming = 100,
      font = 'IMPACT',
      fontSize = 48,
      highlightColour = '&H00FF00&',
      maxLinesOnScreen = 4,
      screen,
    } = options || {};

    const { width = 1280, height = 720 } = screen || {};

    const initialStartPos = height / maxLinesOnScreen;
    const positions = Array(maxLinesOnScreen)
      .fill((_: any) => undefined)
      .map((_, i) => initialStartPos + fontSize * i);
    const CENTER_X = width / 2;

    const ASS_TEMPLATE = `[Script Info]
; Script generated by Aegisub 3.4.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1280
PlayResY: 720

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${font},${fontSize},&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Countdown,Arial Black,80,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,5,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

    const assLines: string[] = [];
    const lines: AssLine[] = [];
    const HIGHLIGHT_TEMPLATE = `\\r\\1c${highlightColour}`;

    for (const line of lyricLines) {
      const startingTiming = line.startTime;

      const paddingStart = startingTiming - paddingTiming;
      const paddingEnd = startingTiming + paddingTiming;

      lines.push({
        start: paddingStart,
        end: paddingEnd,
        lyric: line.str,
      });
    }

    const countdownLines = constructCountdown(
      lines[0].start + paddingTiming,
      3,
      paddingTiming,
    );

    for (const line of countdownLines) {
      const startTiming = convertTiming(line.start);
      const endTiming = convertTiming(line.end);

      const prefixTemplate = `{\\pos(${CENTER_X},${height / 2})}`;
      const formattedLine = `Dialogue: 0,0:${startTiming},0:${endTiming},Countdown,,0,0,0,,${prefixTemplate}${line.lyric}`;
      assLines.push(formattedLine);
    }

    for (let i = 0; i < lines.length; i += maxLinesOnScreen) {
      const chunk = lines.slice(i, i + maxLinesOnScreen);

      for (let j = 0; j < chunk.length; j++) {
        const line = chunk[j];
        const startTiming = convertTiming(line.start);
        const endTiming = convertTiming(line.end);
        const pos = positions[j];

        // TODO: If the timings between the next end and start are far away we can reset back to positions[0]

        const prefixTemplate = `{\\k${paddingTiming}${HIGHLIGHT_TEMPLATE}\\pos(${CENTER_X},${pos})}`;
        const formattedLine = `Dialogue: 0,0:${startTiming},0:${endTiming},Default,,0,0,0,,${prefixTemplate}${line.lyric}`;
        assLines.push(formattedLine);
      }
    }

    return `${ASS_TEMPLATE}${assLines.join('\n')}`;
  };

  return {
    toAss,
  };
};
