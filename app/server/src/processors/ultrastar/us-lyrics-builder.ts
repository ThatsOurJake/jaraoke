import type {
  AssLine,
  LyricBuilderAssOptions,
  UltrastarFile,
  UltrastarNote,
} from 'jaraoke-shared/types';

export const usLyricsBuilder = (ultrastarFile: UltrastarFile) => {
  const { notes, gap = 0 } = ultrastarFile;

  const constructNotes = () => {
    const groups: UltrastarNote[][] = [];
    let current: UltrastarNote[] = [];

    for (const note of notes) {
      const { endOfPhrase } = note;

      current.push(note);

      if (endOfPhrase) {
        groups.push(current);
        current = [];
      }
    }

    return groups;
  };

  const constructCountdown = (
    firstTiming: number,
    startingNumber: number = 3,
    paddingTiming: number = 100,
  ): AssLine[] => {
    return Array(startingNumber)
      .fill(() => undefined)
      .map((_, index) => {
        const number = startingNumber - index;
        const milliseconds = number * 1000;

        return {
          start: firstTiming - milliseconds - 1000 - paddingTiming,
          end: firstTiming - milliseconds - paddingTiming,
          lyric: `{\\fad(300,300)}${number}`,
          style: 'Countdown',
        };
      });
  };

  const convertTiming = (value: number) => {
    const totalSeconds = Math.floor(value / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const ms = value % 1000;
    const centiseconds = Math.floor(ms / 10);

    const pad = (num: number) => num.toString().padStart(2, '0');

    return `${pad(minutes)}:${pad(seconds)}.${pad(centiseconds)}`;
  };

  const toAss = (options?: LyricBuilderAssOptions) => {
    const {
      paddingTiming = 100,
      font = 'IMPACT',
      fontSize = 48,
      highlightColour = '&H00FF00&',
      maxLinesOnScreen = 4,
      screen,
    } = options || {};
    const { width = 1280, height = 720 } = screen || {};

    const noteGroups = constructNotes();

    const initialStartPos = height / maxLinesOnScreen;
    const positions = Array(maxLinesOnScreen)
      .fill((_: any) => undefined)
      .map((_, i) => initialStartPos + fontSize * i);
    const CENTER_X = width / 2;

    const ASS_TEMPLATE = `[Script Info]
; Script generated by Aegisub 3.4.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1280
PlayResY: 720

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${font},${fontSize},&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Countdown,Arial Black,80,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,5,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

    const assLines: string[] = [];
    const lines: AssLine[] = [];
    const HIGHLIGHT_TEMPLATE = `\\r\\1c${highlightColour}`;

    for (const group of noteGroups) {
      const startingTiming = group[0].start;
      const endingTiming = group[group.length - 1].start;

      const paddingStart = startingTiming + gap - paddingTiming * 10;
      const paddingEnd = endingTiming + gap + paddingTiming * 10;

      const parts: { start: number; str: string }[] = [];
      const filteredGroup = group
        .filter((x) => !x.endOfPhrase && x.text !== '~')
        .map((x) => ({
          ...x,
          text: x.text?.replace(/~/g, ''),
        }));

      for (let i = 0; i < filteredGroup.length; i++) {
        const word = filteredGroup[i];
        const nextWordTiming = filteredGroup[i + 1]?.start || endingTiming;
        const start = nextWordTiming - word.start;

        parts.push({
          start: Math.round(start / 10),
          str: word.text!,
        });
      }

      const lyric = parts.map((x) => `{\\k${x.start}}${x.str}`).join('');

      lines.push({
        start: paddingStart,
        end: paddingEnd,
        lyric,
      });
    }

    const countdownLines = constructCountdown(
      lines[0].start + paddingTiming,
      3,
      paddingTiming,
    );

    for (const line of countdownLines) {
      const startTiming = convertTiming(line.start);
      const endTiming = convertTiming(line.end);

      const prefixTemplate = `{\\pos(${CENTER_X},${height / 2})}`;
      const formattedLine = `Dialogue: 0,0:${startTiming},0:${endTiming},Countdown,,0,0,0,,${prefixTemplate}${line.lyric}`;
      assLines.push(formattedLine);
    }

    for (let i = 0; i < lines.length; i += maxLinesOnScreen) {
      const chunk = lines.slice(i, i + maxLinesOnScreen);

      for (let j = 0; j < chunk.length; j++) {
        const line = chunk[j];
        const startTiming = convertTiming(line.start);
        const endTiming = convertTiming(line.end);
        const pos = positions[j];

        // TODO: If the timings between the next end and start are far away we can reset back to positions[0]
        const prefixTemplate = `{\\k${paddingTiming}${HIGHLIGHT_TEMPLATE}\\pos(${CENTER_X},${pos})}`;
        const formattedLine = `Dialogue: 0,0:${startTiming},0:${endTiming},Default,,0,0,0,,${prefixTemplate}${line.lyric}`;
        assLines.push(formattedLine);
      }
    }

    return `${ASS_TEMPLATE}${assLines.join('\n')}`;
  };

  return {
    toAss,
  };
};
